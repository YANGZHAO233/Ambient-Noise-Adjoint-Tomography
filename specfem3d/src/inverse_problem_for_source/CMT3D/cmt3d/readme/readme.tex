%
%=======================================
%  template.tex
%=======================================
%
\documentclass[12pt,titlepage,fleqn]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage[round]{natbib}
\usepackage{xspace}
%\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{bm}
\usepackage[usenames]{color}
\usepackage{enumerate}

% do not use when showing Table of Contents
%\usepackage{fancybox}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyheadoffset[R]{12pt}
\lhead{}
\chead{}
\rhead{Q Liu}

% SPACING COMMANDS (Latex Companion, p. 52)
\usepackage{setspace}
\renewcommand{\baselinestretch}{1.0}
\textwidth 470pt
\textheight 630pt
\oddsidemargin 0pt
\evensidemargin 0pt

% see Latex Companion, p. 85
%\voffset     -50pt
\topmargin     0pt
\headsep      20pt
\headheight   15pt
\headheight    0pt
\footskip     30pt
\hoffset       0pt

% nicer fonts
\usepackage{times}

% self-defined commands
\include{newcommands}

% bibliography
\bibliographystyle{gji}

%======================================================
\begin{document}
%======================================================
\begin{spacing}{1.0} % empty lines are required!
\begin{center}

\Large {\vspace{0.1in} \bf \verb+CMT3D_FLEXWIN+ Manual}

\small
Qinya Liu \\
Department of Physics \\
%Faculty of Arts and Science \\
University of Toronto

\today

\end{center}

\end{spacing}

%======================================================
\verb=CMT3D_FLEXWIN= is re-written from my old \verb=CMT3D= program to reflect the gist of the program, which is to use Gaussian elimination to solve the source inverse problem, In particular,
\begin{itemize}
\item directly use the output windows file from Alessia's \verb=FLEXWIN= package, which selects time windows with decent match between data and synthetics.
\item eliminate bandpass filter as it should have been applied before entering \verb+FLEXWIN+.
\item  by default, inversions are done in local coordinates \{\verb+dep,lon,lat+\}. However, with \verb+global_coord=.true.+, it also allows inversions to be done in global coordinates \{\verb+X,Y,Z+\}, which may come in handy for future multiple source inversions. The  bottom line is that the code is written such that it should be able to take the old parameter files and run exactly the same as before (in local coordinates) without even specifying this logical.
\item incorporate centroid time shift and half duration as inversion parameters (npar=10 and 11), although derivatives for hdur and tshift have to be precomputed by python scripts \red{(which one?)}
\end{itemize}
What still remains to be added is the possiblity of \verb+CMT3D+ inversion for multiple subevents, which may be useful if $N_{event}$ is relatively small, and may be handy for efficiency comparisons to \verb+CMT3D_CG+.


%===========================================================
\section{Setup}

\subsection{Setup derivative cmt solutions}
According to the theory in the Appendix, we need to compute the derivative synthetics by brute force difference formula
\eq \papa{s}{m} \sim \frac{s(m+\Delta m)-s(m)}{\Delta m} \en
for all source parameters involved in the inversion. Depending on how many parameters are chosen (\verb+npar+), we need to run at least $6-9$ SEM simulations to gather all the derivatives. Each SEM simulation requires a corresponding \verb+CMTSOLUTION+ for $m+\Delta m$, and the $\Delta m$ should be chosen carefully to avoid either numerical inaccuracy or instability. In the local coordinates  \{\verb+dep,lon,lat+\}, for the global code (\verb+SPECFEM3D_GLOBE+), a choice may be
\eq
\Delta M = 1\times 10^{24}\text{ dyne.cm},\quad \Delta X = 2\text{ km (depth)}, \quad \Delta\delta=0.02 \text{ deg  (lat/lon)}
\en
and for the basin code (\verb+SPECFEM3D+), a choice may be
\eq
\Delta M = 1\times 10^{22}\text{ dyne.cm},\quad \Delta X = 0.5\text{ km}, \quad \Delta\delta=0.01
\en
where $\Delta X$ refers to depth perturbations and $\Delta \delta$ refers to perturbation in latitude and longitude.

Depending on what coordinate system you choose to calculate derivatives and run \verb+CMT3D+ inversions, different extensions are expected for derivative \verb+CMTSOLUTION+s as well as derivative synthetics (generated by \verb+gen_der_cmt()+ python script):
\begin{itemize}
\item local (depth, lon, lat) coordinates (\verb+global_coord=.false.+):\\
   \verb+ext=['Mrr','Mtt','Mpp','Mrt','Mrp','Mtp','dep','lon','lat']+\\
This system should used as default for most applications.

\item global code, global (X,Y,Z) coordinates (\verb+global_coord=.true.+):\\
   \verb+ext=['Mxx','Myy','Mzz','Mxy','Mxz','Myz','xxx','yyy','zzz']+\\
This coordinate system may only be used to accommodate multiple event inversions in the future. For derivations of rotation matrices, please refer to the Appendix.

\end{itemize}

Note:
\begin{enumerate}
\item
Python script and modules are provided in \verb+scripts+ directory to facilitate this process, and allow full compatibility with \verb+CMT3D+ code:
\begin{verbatim}
 gen_cmt_der('CMTSOLUTION',npar=9,dmoment=1.e24,
              ddepth=2,dlocation=0.02,utm=0)
\end{verbatim}
where $dmoment$, $ddepth$ and $dlocation$ are given in dyne$\cdot$cm, km and degrees ($\Delta X=111.12\Delta \delta $), and $utm=0$ refers to local coordinates  (depth, lon, lat).

If $utm=-1$, it refers to global coordinates (X, Y, Z), and \verb+ddepth=dX+, \verb+dlocation=dY=dZ+ (may need to modified in future).
Note that \verb+gen_cmt_der+ does allow utm to be 1-60, and map  small regions into a cartesian geometry (depth, E, N). But that is NOT yet used for the \verb+cmt3d+ package.
\item Also as discussed in the theory section, derivatives for centroid time and half duration simply depend on the original synthetics, and  no extra simulation is necessary. \red{how to compute?}
\item After simulations for these derivative \verb+CMTSOLUTION+s are finished, collect synthetic seismograms, convert them to sac files and add proper extension to the sac files according to the choice of coordinate system.

\item Note synthetics for the original \verb+CMTSOLUTION+ do not need to be obtained through an extra simulation, a simple linear combination of moment tensor derivatives can be realized by:
\begin{verbatim}
 xadd_frechet_derivatives s syn_list cmt moment_scale(1e24)
\end{verbatim}

\end{enumerate}

\subsection{Pre-processing data and synthetics}

After gather raw data from IRIS (for global earthquakes) or SCEDC (for socal earthquakes), and collect synthetics as well derivative synthetics from SEM simulations, you need to go through the pre-processing step to present properly cut and filtered data and synthetics to the \verb=FLEXWIN= package. I have come a long way in writing such scripts, and right now I am settled on a recent one in python:
\begin{verbatim}
 process_ds.py  \
  -d data,sac -s syn,  -p CMTSOLUTION,STATIONS\
  -t 6,30 -w -D [-r]
\end{verbatim}
%\verb=-d= and \verb=-s= give directory names and extension names of the raw data and synthetics. \verb=-0=,\verb=-1=\verb=-2=,\verb=-3= represents different pre-processing stages which you can choose to run separately. During \verb=-0=, information is gathered from \verb=CMTSOLUTION= and \verb=station_file= and written into sac headers. New directories \verb=data_PP= and \verb=syn_PP= are created to host these pre-processed data and syn files. During \verb=-1= stage, data and synthetics are padded before the beginning time to a value specified by \verb=-b=, and proper cutting between data and synthetics are performed to ensure futher operations. \verb=-2= stage mainly deals with band-passing data and synthetics between the frequence bands given by \verb=-t=, and moving the new processed files to directories \verb=data_T006_T030= and \verb=syn_T006_T030=. \verb=-3= stage writes out the input file \verb=flexwin_T006_T030.input= for \verb=FLEXWIN= package after all the above steps have been executed. The script structure and many implementation details are inspired by a similar script written by Carl Tape.
For detailed usage, simple type \verb+process_ds.py+. The outcomes of this script are
\begin{itemize}
\item filtered data and (derivative) synthetics in \verb+data_6_30+ and \verb+syn_6_30+.
\item an input file to \verb+FLEXWIN+ named \verb+INPUT_flexwin_6_30+ will be generated.
\end{itemize}

\subsection{Executing FLEXWIN}
After choosing the right parameters in \verb=PAR_FILE= and user functions for flexwin package (please refer to \verb+FLEXWIN+ manual for details), simply run
\begin{verbatim}
./flexwin < INPUT_flexwin_6_30 > OUTPUT_flexwin_6_30
\end{verbatim}
After running \verb+FLEXWIN+ through data and synthetics filtered at various period bands (e.g., \verb+3-30+ and \verb+6-30+ secs),  all individual windows files in \verb+MEASURE_t1_t2+ directories can be cat into an input for \verb=cmt3d_flexwin= package.
\begin{verbatim}
write_flexwin_out.py MEASURE_6_30 MEASURE_20_50  \
                     INPUT_cmt3d_flexwin_noweight
\end{verbatim}
Now it is possible to pad time shift and weight information to the composite output windows file (after the time range of the window), either to facilitate a direct evaluation of misfit function, or to eliminate the weight calculations in \verb+CMT3D+ package, which can be rather cumbersome and inflexible.
\begin{verbatim}
write_flexwin_shift_weight.py -c 2/2/1 -d 1.15/0.55/0.78 -a 0.2 -r 2 -t \
      -D data -s MEASURE  INPUT_cmt3d_flexwin_noweight \
      INPUT_cmt3d_flexwin_withweight
\end{verbatim}
Obviously you can not just blindly use this package without checking. Here are two auxilliary scripts:
\begin{verbatim}
plot_flexwin.py MEASURE
plot_data_and_syn.pl -d data_dir,data_ext -s syn_dir,syn_ext -m cmt \
   -M OUTPUT_flexwin -A (Z/R/T) 0.05/0.05/0.08
\end{verbatim}
The first script gives \verb+flexwin_seismo.pdf+ and the second one gives \verb+ds_all.pdf+.
%============================================
\section{CMT3D package}
\subsection{Parameter file}
For structures of the main program and subroutine calls, refer to \verb=call-graph=. The name of the parameter file is hard-wired in the main program as \verb=INVERSION.PAR=.

\begin{verbatim}
CMTSOLUTION
CMTSOLUTION_NEW
6  .false.                      -- npar[, global_coord]
0.01 1.0  1.0e22                -- dlocation,ddepth,dmoment
flexwin.out
.true. .false.                 -- weigh_data_files[, read_weight]
2 2 1  0  1.15 0.55 0.78       -- weights of data comp,az,dist
.true.                         -- station_correction
.true.  .true. 0.0             -- zero_trace,double_couple,damping
.false.                        -- write_new_syn (psuedo-synthetics)
\end{verbatim}
The first line gives the old cmt solution file name. This is also the cmt solution you have used to generate derivative cmts and compute the synthetics from linear combinations. The second line gives name of the new cmt solution file output after the inversion is done.\\
File \verb=flexwin.out= holds the start and end time of the windows outputed from FLEXWIN package, in the following format:
\begin{verbatim}
nfiles
data-file-1
syn-file-1
 nwins-for-this-data-and-syn
 tstart(1) tend(1) [tshift(1) weight(1)]
 ...
 tstart(nwin) tend(nwin) [tshift(nwin) weight(nwin)]
data-file-2
syn-file-2
...
\end{verbatim}
Only data points inside the windows from \verb+flexwin.out+ file will be used to perform time integration and assemble the inversion matrices. Note the values in [] are recent additions where we allow weights to be specified in the input file together with an indicative logical \verb+read_weight+. For now, \verb+tshift+ is still a dummy variable not used for aligning data and synthetics (a separate xcorr subroutine calculates it in the code, but future merge may be possible).

All other parameters are pretty self-explanatory:
\begin{itemize}
 \item Number of parameters to be inverted can only be 6(moment-only), 7(moment+depth), 9(moment+locations). \verb+global_coord+ indicates if the input derivative synthetics are in terms of $(X,Y,Z)$ or $(depth,lon,lat)$.
 \item For local coordinates, the derivative synthetics should have been calculated based on the \verb=dlocation= (in degrees), \verb=ddepth= (in km), \verb=dmoment= (in dyne$\cdot$cm) values. However, notice that strictly speaking, only the ones for moment are actual derivative synthetics; the ones for depth, longitude, and latitude (or \red{R, S, E} depending on coordinate system or utm) are actual synthetics, from which the code subtracts the old synthetics and divides it by ddepth or ddelta (refer to Appendix for more details).
 \item Weighting subroutine \verb=compute_data_weights()=  needs to be tweaked if you choose to \verb=weigh_data_files=, and not importing weights directly from the input file by \verb=read_weight=. The idea is that you utilize the \verb=dist_km=, \verb=dist_deg=, \verb=azimuth=, and other file information from the sac headers to come up with a sensible weighting scheme for your particular scale/region.
 \item Station correction is used to align the data with the synthetics to accommondate 3D path effects that may bias your source inversion results.
 \item Different constraints on the moment-tensor are allowed, including zero-trace and double-couple. To improve the stability of the matrix inverse (when only very few windows are used), damping is also allowed before Gaussian elimination.
 \item Finally synthetics for the new cmt solution can be written, however, notice that these are obtained from `linearized' approximation, not from an actual SEM simulation.
 \end{itemize}

Some more words on weighting:
\begin{itemize}
\item If you want to invert either only surface waves or body waves, make sure you set the optimal parameters in \verb+FLEXWIN+ to get the correct sets of windows.

\item How do the weights work in \verb=compute_data_weights()=:
\begin{verbatim}
        data_weights(nwint) =  cmp_weight(nwint) &
             * (dist/REF_DIST) ** dist_exp_weight(nwint) &
             * corr(nwint) ** corr_exp_weight(nwint) &
             / ( naz(k) ** az_exp_weight)
\end{verbatim}
 where component weights are applied linearly, distance and azimuth weights are applied exponentially (such that $0$ means no weight and $1$ means linear weight). \verb=naz(k)= is the number of traces available in a particular azimuth bin (\verb=+1=). One can set \verb=az_exp_weight= to be 0 to mute out the azimuthal effect, the same for distance weights.

\end{itemize}

\subsection{Synthetic data tests}
This package has been fully tested for $6,7,9,10$ parameter inversions based on synthetic data.

%======================================================

\appendix
\section{CMT3D Theory}
\subsection{Moment-tensor Inversions}
We seek to minimize the difference between data $\{d_i(t),i=1,\ldots,N\}$ and corresponding synthetics $\{s_i(\bbm,t),i=1,\ldots,N\}$  computed for a given model parameters $\bbm=\{m_j,j=1,\ldots,M\}$ after applying some bandpass filter:
\eq
\phi(\bbm)=\oneovertwo \sum_{rq}  \int\,W_{rq}(t)\left[ \bs^b(\bbm,\bx_r,t)-\bd^b_i(\bx_r,t)\right]^2\,dt
\en
where $W_{rq}(t)$ combines the taper function with weighting factor for the q'th window at r'th receiver. $\bs^b$ and $\bd^b$ denote filtered data and synthetics.

If we take the first and second order derivatives of this misfit function at some given reference model $\bbm^0$, we obtain
\eqa
\papa{\phi(\bbm^0)}{m_j} &=& \sum_{i=rq} \int\,W_{rq}(t)\left[ \bs^b(\bbm^0,\bx_r,t)-\bd^b(\bx_r,t)\right]\papa{s_i(\bbm^0,\bx_r,t)}{m_j}\,dt \\
\papapan{\phi(\bbm^0)}{m_j}{m_k} &\sim& \sum_{i=rq}  \int\,W_{rq}(t)\papa{\bs^b(\bbm^0,\bx_r,t)}{m_j}\papa{\bs^b(\bbm^0,\bx_r,t)}{m_k}\,dt
\label{eq:first-second-der}
\ena
where for the second-order derivatives, we have omitted the term related to second-order synthetics derivatives, i.e. approximate Hessian

By assuming that at the optimal model parameter $\bbm$, we have $\papa{\phi}{\bbm}=0$, which translates to the quasi-Newton's method:
\eq
\papa{\phi(\bbm^0)}{m_j}+\papapan{\phi(\bbm^0)}{m_j}{m_k}(m_k-m_k^0) = 0
\en
Therefore, we just need to compute the first and second-order derivatives according to equations \ref{eq:first-second-der}, which further points to the computation of derivative synthetic seismograms $\papa{s_i(\bbm^0)}{m_j}$.
%======================================================

\subsection{Derivative Synthetics}
We know in general, the synthetics for model $\bbm$ can be expanded with respect to a reference model $\bbm^0$:
\eq
s(\bbm,t)=s(\bbm^0,t) + \sum_{j=1}^M \papa{s_i(\bbm^0,t)}{m_j} (m_j-m_j^0)
\en
If source parameters only include moment-tensor elements, then the linear dependences can be written as:
\eq
s(\bbm,t,t) = \sum_{j=1}^{M}\papa{s_i(\bbm^0,t)}{m_j} m_j
\en
Therefore derivatives for moment-tensor elements can be computed by
\eq
\papa{s_i(\bbm^0,t)}{M_j} = s(M_j^0,t)/M_j^0
\en
where $s(M_j^0,t)$ is the synthetics calculated by setting all the moment tensor elements other than the $j$th component to $0$.

For other source parameters, including event location and depth, a finite-difference formula has to be used:
\eq
\papa{s_i(\bbm^0,t)}{m_j} = \frac{s(m_j^0+\De m_j^0,t)-s(m_j^0,t)}{\De m_j}
\en
where $s(m_j^0+\De m_j^0,t)$ refers to synthetics computed from only perturbing the $j$'th component of the source parameters. $\Delta m_j$ needs to be selected with care to avoid numerical noise. Typically $2-5$ km for global earthquakes and $1$ km for local earthquakes.

Derivatives for time shift and half duration can be derived from the original synthetics itself. Given a Gaussian source time function
\eq
g(t) = \frac{1}{\sqrt{\pi}t_h}e^{-\left(\frac{t-t_s}{t_h}\right)^2} \quad
\text{or}\quad g(\om) = e^{-\frac{\om^2 t_h^2}{4}} e^{-i\om t_s}
\en
under the Fourier transformation pairs:
\eq
F(\om) = \int_{-\infty}^{\infty} f(t) e^{-i\om t}dt, \quad f(t+a) \Leftrightarrow F(\om) e^{i\om a},
\quad \dot{f}(t) \Leftrightarrow (i\om) F(\om)
\en
Given Green's functions for a point source with delta moment function, we can express the synthetics for an earthquake as
\eq
\bs(\bx_r,\om) = \frac{M}{i\om} : \nab G(\bx_r,\bx_s,\om) g(\om)
\en
i.e., synthetics for error function as moment function.  Therefore
\eq
\papa{\bs(\bx_r,\om)}{t_{s,h}} = \frac{M}{i\om} : \nab G(\bx_r,\bx_s,\om)\papa{g(\om)}{t_{s,h}}.
\en
Since
\eqa
\papa{g(\om)}{t_s} &=& -(i\om) g(\om)  \nn \\
\papa{g(\om)}{t_h} &=& -\frac{1}{2} t_h \om^2 g(\om) = -\oneovertwo t_h (i\om) \papa{g(\om)}{t_s}
\ena
we have
\eqa
\papa{s(\bbm_0,t)}{t_s} &=& -\dot{\bs}(\bbm_0,t) \nn \\
\papa{s(\bbm_0,t)}{t_h} &=& -\frac{1}{2}t_h \pa_{t} [\papa{s(\bbm_0,t)}{t_s}]
\ena
%======================================================
\subsection{Rotation between Global and Local coordinates}
A series rotation is needed to tranform local $(r,\tht,\phi)$ coordinates
(which is also what CMT moment tensor uses) into the global coordinates $(X,Y,Z)$, where $X$ is pointing to $\Deg{0}$ longitude, and vice versa.

For a given point with $(\tht=90-Lat,\phi=Long)$ on a \textbf{unit} sphere, the coordinates in the cartesian global coordinate system is given by
\eq
X=\sin\tht\cos\phi,\quad Y=\sin\tht\sin\phi,\quad Z=\cos\tht
\en
Conversely, given the global coordates $(X,Y,Z)$,
\eq
\tht = acos(Z/r),\quad  \phi=atan2(Y/\sin\tht, X/\sin\tht)
\en
Note here if $\tht=0$ (North pole), then $\phi$ is undetermined, and can be basically any number.

For rotation matrices, as an example, in 2-D, for the same point, the coordinates under new coordinate system is related to the old coordinates by
\eq
\begin{bmatrix} X_{new} \\ Y_{new}\end{bmatrix}
= \begin{bmatrix} \cos\tht & \sin\tht \\ -\sin\tht & \cos\tht \end{bmatrix}
\begin{bmatrix} X_{old} \\ Y_{old}\end{bmatrix}
\en
\begin{figure}[h]
\putfigure{5in}{rot.png}
\caption{Rotation matrices}
\end{figure}
After the first two simple rotations ($Z (\phi)$ and $Y(\tht)$) demonstrated by Figure 1, we have the relation between $(X,Y,Z)$ and $(\tht,\phi,r)$ systems:
\eq
\begin{bmatrix} x_{\tht} \\ x_{\phi} \\ x_{r} \end{bmatrix}
= \begin{bmatrix} \cos\tht & 0 & - \sin\tht \\
0 & 1 & 0 \\ \sin\tht & 0 & \cos\tht \end{bmatrix}
\begin{bmatrix} \cos\phi & \sin\phi & 0 \\
-\sin\phi & \cos\phi & 0 \\ 0 & 0 & 1 \end{bmatrix}
\begin{bmatrix} X \\ Y \\ Z\end{bmatrix}
\en
This is not the end of story, as the usual order of local coordinate system is $(r,\tht,\phi)$ instead of $(\tht,\phi,r)$. Therefore two extra rotations ($Y(-\Deg{90})$ and $X (-\Deg{90})$) are needed, which give an extra (left-applied) rotation matrix
\eq
\begin{bmatrix} 1 & 0  &  0 \\
0 & \cos(-\Deg{90}) & \sin(-\Deg{90}) \\
0 & -\sin(-\Deg{90}) & \cos(-\Deg{90}) \end{bmatrix}
\begin{bmatrix} \cos(-\Deg{90}) & 0 & -\sin(-\Deg{90}) \\
0 & 1 & 0 \\
\sin(-\Deg{90}) & 0  & \cos(-\Deg{90}) \end{bmatrix}
\en
Multiply these two matrices together, we obtain the final rotation matrix from $(X,Y,Z)$ to $(r,\tht,\phi)$:
\eq
R^T=
\begin{bmatrix}
\sin\tht\cos\phi & \sin\tht\sin\phi  &  \cos\tht \\
\cos\tht\cos\phi & \cos\tht\sin\phi & -\sin\tht \\
-\sin\phi & \cos\phi & 0 \end{bmatrix}
\en
which can be verified by
\eq
\begin{bmatrix} 1 \\ 0 \\ 0\end{bmatrix}=
R^T
\begin{bmatrix} \sin\tht\cos\phi \\ \sin\tht\sin\phi \\ \cos\tht\end{bmatrix}
\en
The rotation matrix from local $(r,\tht,\phi)$ to global $(X,Y,Z)$ is simply:
\eq
R=\begin{bmatrix}
\sin\tht\cos\phi & \cos\tht\cos\phi  &  -\sin\phi \\
\sin\tht\sin\phi & \cos\tht\sin\phi & \cos\phi\\
\cos\tht & -\sin\tht & 0 \end{bmatrix}
\en
%======================================================

%============================================

\section{Testing (further update awaits)}

Two types of datasets are provided to accurately test this inversion package, one with station correction, and one without. Synthetics and derivative synthetics for corresponding \verb=CMTSOLUTION= are always in \verb=syn_T006_T030=. No pre-processing are needed for these dataset as they have gone through all the procedures. Although to achieve inversion result that is accurate to several digits after the decimal point, several tweaks with the usual pre-processing procedures have to be done.

\begin{itemize}
\item  \blue{(obsolete, needs fix)} we should not use \verb=-h= in the synthetics processing to ensure that the synthetics data and the derivative synthetics go through the exact same set of processing procedures. we also need to take out the \verb=rtrend= and \verb=rmean= line in the filtering steps of \verb=process_syn_new.pl= and \verb=process_cal_data.pl= (\red{?}). Since the data and synthetics presented in \verb=test_dataset= have gone through the script:
\begin{verbatim}
  process_data_and_syn.pl  -d data,sac -s syn,  \
         -0 -m CMTSOLUTION -a station_file   \
         -1 -b -26 -2 -t 6/30
\end{verbatim}
which generated \verb=process_ds.csh= script for all the commands, we can just tweak individual lines in \verb=process_ds.csh= to achieve our test dataset. Also
note that the \verb=-i none= option for data processing and \verb=-h= option for synthetics processing have to be taken out from the script to make sure that synthetics and data are processed in exactly the same way.

\item The synthetic data for the 7 paramter case are generated by the following command:
\begin{verbatim}
  xadd_frechet_full s syn_file_list old_cmt true_cmt \
                    doment depth dx[dy]
\end{verbatim}
which is a fancier version of the original
\begin{verbatim}
  xadd_frechet_derivatives s syn_file_list \
                           cmt_file moment_scale
\end{verbatim}
Of course we can't really use the true synthetics for the true cmt solution in a 7-par case, since we know that the synthetics is a non-linear function of depth, and the inversion won't accurately recover depth. Linearized `pseudo-synthetics' will ensure accurate results, which is the purpose of testing.

\item It is impossible to design test dataset for 7 parameter inversion with time shift, since time shifts interfer with the effect of waveform change caused by depth variation, therefore, may not give exact solution, and sometimes may even produce the incorrect solution. This is part of the reason why I also wrote the grid search package \verb=GRID3D_FLEXWIN=.
\end{itemize}
%=======================================================

\section{Auxilliary Scripts and Programs}
A list of the scripts that are used before and after the package:
\begin{itemize}
\item \verb=process_data_and_syn.pl=, which includes \\
 \verb=process_data_new.pl=(global/regional) or \verb=process_cal_data.pl= (socal), \\
 \verb=process_syn_new.pl= (global/regional) or \verb=process_trinet_syn_new.pl=(socal), \\
 \verb=pad_zeros.pl= (include \verb=pad_zero_to_syn=), \verb=rotate.pl=, \verb=saclst=. Of course \verb=sac= has to be present in the system.
\item \verb=prepare_meas_all.pl=
\item \verb=xadd_frechet_derivatives= and \verb=xadd_frechet_full=
\end{itemize}


\end{document}
